package com.apama.adbc;

//*****************************************************************************
// ADBC (Apama Database Connector) Connectivity Plugin Event Definitions.
//
// Provides definitions for all events sent to or from the ADBC Connecticivity Plugin. 
//
// $Copyright (c) 2013, 2015 Software AG, Darmstadt, Germany and/or Software AG USA Inc., Reston, VA, USA, and/or its subsidiaries and/or its affiliates and/or their licensors.$
// Use, reproduction, transfer, publication or disclosure is prohibited except as specifically provided for in your License Agreement with Software AG
//
//*****************************************************************************


// TODO: document how people should generate unique IDs e.g. integer.incrementCounter("jdbc");

/**
* Event in response to the StartQuery event to indicate the result's schema.
*
* Note: This event will be sent before the first ResultEvent and only if 
* ReturnType is set to ResultEvent.
*
* See also: StartQuery()
*
* Dataplayer: <br>
*     - Direction: Correlator to client
*
*     Channel: <verbatim><</verbatim>serviceId<verbatim>></verbatim>.Control
*/
event ResultSchema {
	/** Unique id for this request. */
	integer messageId;
	/** The order of the fields in the schema. */
	sequence <string> fieldOrder;
	/** The types of the fields in the schema. */
	dictionary <string, string> fieldTypes;
}

/** A specialised simpler kind of command that just populates a new row with values */
event Store {
	integer messageId;
	string tableName;
	dictionary<string, any> row;
}


/** Execute an SQL statement, which may be a query (returning a set of results) or an update command.

This will be executed as a prepared statement if one or more parameters are provided. 
*/
event Statement {
	/** Unique id identifying this request */
	integer messageId;

	/** SQL to execute. 
	Be sure to strictly validate and escape any user-provided strings included in the SQL 
	to avoid the risk of SQL injection vulnerabilities. 
	
	Alternatively, specify parameters using "?" syntax (which will safely escape them and also result in a prepared statement 
	being used on the database server).  
	*/
	string sql;
	
	/** Parameters for prepared statement. 
	
	If any parameters are provided, the SQL is sent to the database as a prepared statement allowing for 
	fast repeated execution. 
	
	If no parameters are provided, a non-prepared statement is used. Non-prepared statements are typically quicker 
	for single uses (and slower for repeated uses), but you need to be extremely careful to validate and escape 
	any parameters in the sql string to avoid the risk of a SQL injection security vulnerability; if . 
	*/
	sequence<any> parameters;
}

/** Execute an SQL statement, which is expected to have a small number of results that should be returned in a single event.
*
* In this scenario you shoudl expect all results to be returned in one 
* SmallResultsSet event rather than individual ResultSetRows.
*/
event SmallStatement {
	/** Details of the statement to be executed. */
	Statement statement;
	
	/** Indicate the max rows allowed.
	* If it turns out there were more results than expected, only the amount up 
	* to maxSmallQuerySize will be returned and the statement is stopped after that.
	*/
	integer maxSmallQuerySize;	
}

/** Returned for small ResultSets
* if the executed statement is expected to return a small set of results,
* Then they are all returned at once in this event
* rather than individually in separate ResultSetRows.
*/ 
event SmallResultsSet{
	/** Unique id identifying the request */
	integer messageId;
	
	/** The result data. 
	* This is expected to contain a sequence of multiple rows where
	* each dictionary element contains a rows result data.
	*/	
	sequence<dictionary<string,any>> rows;
}

/** Individual row from a ResultSet. Zero or more are sent in response to a Statement. */
event ResultSetRow {
	/** Unique id identifying the request */
	integer messageId;
	/** unique Id for each row
	* This is useful if you ned to rerun a query and don't 
	* expect the underlying data to change.
	*/
	integer rowId;
	/** The row data, keyed by column name. */
	dictionary <string, any> row;
}

/** Sent when a statement has finished executing, either successfully or unsuccessfully.  */
event StatementDone {
	/** Unique id identifying the request. */
	integer messageId;

	/** Number of rows updated by the Statement */
	integer updateCount;

	/** Empty string if it completed successfully, or an error message if it did not. */
	optional<string> error; // TODO: change to a simple string, since can't match on it if use optional

}
