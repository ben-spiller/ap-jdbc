package com.apama.adbc;

//*****************************************************************************
// ADBC (Apama Database Connector) Connectivity Plugin Event Definitions.
//
// Provides definitions for all events sent to or from the ADBC Connecticivity Plugin. 
//
// $Copyright (c) 2013, 2015 Software AG, Darmstadt, Germany and/or Software AG USA Inc., Reston, VA, USA, and/or its subsidiaries and/or its affiliates and/or their licensors.$
// Use, reproduction, transfer, publication or disclosure is prohibited except as specifically provided for in your License Agreement with Software AG
//
//*****************************************************************************

////////////////////////////////////////////////////////////////////////////////
//
// Query events
//
////////////////////////////////////////////////////////////////////////////////

/**
* Sent to plugin to start a database query.
*
* See also: QueryStatus(), ResultSchema(), ResultEvent()
*
* Response: QueryStatus(), ResultSchema(), ResultEvent()
*
* Dataplayer: <br>
*     - Direction: Client to correlator.
*/
event StartQuery {
	/** Unique id for this query. */
	integer messageId;
	/** The service id, Adapter channel name. */
	string serviceId;
	/** Database connection id. */
	integer databaseId;	
	/** Query to run (either query string or name). */
	string query;		
	/** Return Event Type should be one of: Native, Historical, ResultEvent, ResultEventHetero. */
	string returnType;	
	/** Event type (name) for use in mapping rules, needed when using Native returnType. */
	string eventType;
	/**
	* Indicates Query is being used for backtest.
	*
	* <pre>
	* This requires:<br>
	*	1. Only one can be running per database per plugin. <br>
	*	2. All queries must be time sorted. <br>
	*	3. The plugin must be able to identify the time attribute <br>
	*		for all types and possible tie breaker attribute.</pre>
	*/
	boolean backtest;
	/** Generate a status event every n seconds. If n <= 0.0 no status event is generated. */
	float statusFrequency;
	/** Speed for back testing: <= 0.0, as fast as possible, > 0.0 -> some multiple of playback speed. */
	float backtestSpeed;
	/** Column to use for backtest time attribute, not needed if column name is "time". */
	string timeColumn;
	/** PreparedQuery to run. */
	integer preparedQueryId;
	/** Input parameters for preparedQuery. */
	sequence<string> inputParameters; 
	/** This is currently a container to allow additional information in the future. */
	dictionary<string,string> extraParams;
}

/**
* Response to the StartQuery
*
* These will be sent in order until the number requested, in the rowLimit
* specified, in the StartQuery has been sent.
*
* All results will be streamed at once.
*
* See also: StartQuery()
*
* Dataplayer: <br>
*     - Direction: Correlator to client
*/
event ResultEvent {
	/** Unique id for this query. */
	integer messageId;
	/** unique Id for each row
	* This is useful if you ned to rerun a query and dont 
	* expect the underlying data to change.
	*/
	integer rowId;
	/** The result data. */
	dictionary <string, any> row;
}

/**
* Query is done.  errorMessage is NULL if the query has succeeded, not NULL if an
* error has occurred.
* 
* See also: StartQuery()
*
* Dataplayer: <br>
*     - Direction: Correlator to client
*
*     Channel: <verbatim><</verbatim>serviceId<verbatim>></verbatim>.Control
*/
event QueryDone {
	/** Unique id for this query. */
	integer messageId;
	/** Blank on success, otherwise the error message. */
	string errorMessage;
	/** Total number of events sent. */
	integer eventCount;
	/** Timestamp of last event. */
	float lastEventTime;
}


////////////////////////////////////////////////////////////////////////////////
//
// Store events
//
////////////////////////////////////////////////////////////////////////////////

/** A specialised simpler kind of command that just populates a new row with values */
event Store {
	integer messageId;
	string tableName;
	dictionary<string, any> row;
}



////////////////////////////////////////////////////////////////////////////////
//
// Database command events
//
////////////////////////////////////////////////////////////////////////////////

/**
* Sent to plugin to perform maintenance operations such as update or delete.
*
* Response event: CommandAck; errorMessage is blank on success, or
* otherwise a description of the error
*/
event Command {
	/** Unique request-response matching number. */
	integer messageId;
	/** Command string (Update, delete, etc.). */
	string operationString;
}

/**
* The acknowledgement event for Command.
*/
event CommandAck
{
	/** Unique request-response matching number. */
	integer messageId;
	/** Populated with an errorMessage if there is one. */
	string errorMessage;
}

